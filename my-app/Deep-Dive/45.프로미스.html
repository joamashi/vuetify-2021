<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title></title>
</head>
<body>
  <input type="text">
<script>
  /*
    45.1 비동기 처리를 위한 콜백 패턴의 단점
  */
  {
    // GET 요청을 위한 비동기 함수
    const get = url => { // 비동기 함수. 함수 내부에 비동기로 동작하는 코드를 포함한 함수
      const xhr = new XMLHttpRequest()
      xhr.open('GET', url)
      xhr.send()

      xhr.onload = () => {
        if (xhr.status === 200) console.log(JSON.parse(xhr.response))
        else console.log(`${xhr.status} ${xhr.statusText}`)
      }
    }
    get('http://jsonplaceholder.typicode.com/posts/1')
    /*
      {
        title: "sunt aut facere repellat provident occaecati excepturi optio reprehenderit", body: "quia et suscipit↵suscipit recusandae consequuntur …strum rerum est autem sunt rem eveniet architecto"}
        body: "quia et suscipit↵suscipit recusandae consequuntur expedita et cum↵reprehenderit molestiae ut ut quas totam↵nostrum rerum est autem sunt rem eveniet architecto"
        id: 1
        title: "sunt aut facere repellat provident occaecati excepturi optio reprehenderit"
        userId: 1
      }

      비동기 함수를 호출하면 함수 내부의 비동기로 동작하는 코드가 완료되지 않는다 해도 기다리지 않고 즉시 종료된다. 
      
      즉, 비동기 함수 내부의 비동기로 동작하는 코드는 비동기 함수가 종료된 이후에 완료된다. 
      
      따라서 비동기 함수 내부의 비동기로 동작하는 코드에서 처리 결과를 외부로 반환하거나 상위 스코프의 변수에 할당하면 기대한 대로 동작하지 않는다.

      GET 요청을 전송하는 서버의 응답을 전달받는 get 함수도 비동기 함수다.

      get 함수가 비동기 함수인 이유는 get 함수 내부의 onload 이벤트 핸들러가 비동기 동작하기 때문이다.
    */

    {
      // GET 요청을 위한 비동기 함수
      const get = url => {
        const xhr = new XMLHttpRequest()
        xhr.open('GET', url)
        xhr.send()

        xhr.onload = () => {
          if (xhr.status === 200) return JSON.parse(xhr.response)
          else console.log(`${xhr.status} ${xhr.statusText}`)
        }
      }
      const response = get('http://jsonplaceholder.typicode.com/posts/1')
      console.log(response) // undefined
    }

    {
      document.querySelector('input').oninput = function () {
        console.log(this.value)
        return this.value
      }
    }
  }
</script>
</body>
</html>